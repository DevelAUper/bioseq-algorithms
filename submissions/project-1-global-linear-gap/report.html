<html><head><meta charset='utf-8'><style>
body { font-family: Arial, sans-serif; max-width: 800px; margin: 40px auto; line-height: 1.6; font-size: 14px; }
table { border-collapse: collapse; width: 100%; }
th, td { border: 1px solid #ccc; padding: 6px 10px; text-align: left; }
code { background: #f4f4f4; padding: 2px 4px; }
pre { background: #f4f4f4; padding: 10px; overflow-x: auto; }
h1 { font-size: 22px; }
h2 { font-size: 18px; }
h3 { font-size: 15px; }
</style></head><body><h1>Project 1 Report: Global Alignment with Linear Gap Cost â€” Group 3</h1>
<p><strong>Authors:</strong> Andreas Anastasiou and Eduardo Iglesias<br />
<strong>Date:</strong> 17 Feb 2026</p>
<h2>Introduction</h2>
<p>All components work as expected. Both programs produce correct results for all test cases provided by the course (<code>project1_examples.txt</code>) and for the evaluation sequences (<code>project1_eval.txt</code>).<br />
The <code>global_linear</code> tool computes one optimal global alignment and reports its total cost (with optional traceback output).<br />
The <code>global_count</code> tool computes the same optimal cost and the number of optimal alignments.<br />
The scoring model is distance-like, so the implementation performs <strong>cost minimization</strong> (lower values are better).<br />
Inputs are two sequences (typically FASTA), a Phylip-like cost matrix, and a linear gap penalty (<code>gap</code>).<br />
The submission is packaged for easy one-click execution so a tutor can run it directly without code changes.</p>
<h2>Methods</h2>
<h3>Core alignment model (minimize cost)</h3>
<p>For two sequences <code>s1</code> and <code>s2</code>, dynamic programming (DP) is used.<br />
Each DP cell <code>(i, j)</code> represents the best (minimum) alignment cost for prefixes <code>s1[0..i)</code> and <code>s2[0..j)</code>.</p>
<p>The recurrence is:</p>
<pre><code class="language-text">dp[i][j] = min(
dp[i-1][j-1] + matrix.cost(s1[i-1], s2[j-1]),   // diagonal: match or substitution
dp[i-1][j]   + gap,                               // up:       gap in s2
dp[i][j-1]   + gap                                // left:     gap in s1
)
</code></pre>
<p>Plain-language meaning of the three options:
- <strong>Diagonal:</strong> align one symbol from each sequence (match or substitution).
- <strong>Up:</strong> align a symbol in <code>s1</code> to a gap (<code>-</code>) in <code>s2</code>.
- <strong>Left:</strong> align a symbol in <code>s2</code> to a gap (<code>-</code>) in <code>s1</code>.</p>
<h3>Backtracking in <code>global_linear</code></h3>
<p>After the DP cost table is filled, stored move directions are followed from the last cell back to <code>(0,0)</code>.<br />
This reconstructs one optimal alignment by appending characters/gaps and reversing at the end.</p>
<h3>Counting in <code>global_count</code></h3>
<p>A second DP table <code>count[i][j]</code> is maintained alongside the cost table <code>dp[i][j]</code>.<br />
Base cases are initialized as <code>count[0][0] = 1</code>, <code>count[i][0] = 1</code>, and <code>count[0][j] = 1</code>, because there is exactly one way to align any prefix with an empty sequence (all gaps).<br />
For each interior cell <code>(i, j)</code>, the optimal cost is computed first (same three transitions as in the main DP).<br />
Then we set <code>count[i][j] = 0</code> and add counts from every predecessor move that achieves that same optimal cost.<br />
This correctly handles ties: if multiple moves are optimal, all corresponding path counts are summed.<br />
The final answer is <code>count[n][m]</code>.<br />
<code>BigInteger</code> is used for counts because values can become large (for example, <code>138240</code> for <code>seq3</code> vs <code>seq4</code>).</p>
<pre><code class="language-text">best = min(diag, up, left)
count[i][j] = 0
if diag == best: count[i][j] += count[i-1][j-1]
if up   == best: count[i][j] += count[i-1][j]
if left == best: count[i][j] += count[i][j-1]
</code></pre>
<h3>File formats</h3>
<h4>FASTA</h4>
<p>Expected structure:
- Header line starts with <code>&gt;</code>
- Sequence lines follow
- Multi-line sequence content is concatenated</p>
<p>Example (3 lines):</p>
<pre><code class="language-text">&gt;seq1
ACGTTGCA
</code></pre>
<h4>Matrix file (Phylip-like)</h4>
<p>Format:
1. First non-empty line: alphabet size <code>n</code>
2. Next <code>n</code> lines: one symbol, then <code>n</code> integer costs</p>
<p>Small DNA example (<code>A/C/G/T</code>, values 0/5/2):</p>
<pre><code class="language-text">4
A 0 2 5 2
C 2 0 2 5
G 5 2 0 2
T 2 5 2 0
</code></pre>
<p>If an input sequence contains unknown symbols (not in the matrix alphabet), execution stops with an error message.</p>
<h3>Design choices (module structure)</h3>
<p>The implementation is split into three modules to make review and grading straightforward:
- <code>core</code>: sequence objects, FASTA reading, matrix/alphabet parsing, and gap-cost utilities.
- <code>pairwise-alignment</code>: global DP algorithms for optimal cost/alignment and optimal-alignment counting.
- <code>cli</code>: command-line parsing and output formatting, with no algorithm logic.</p>
<p>This keeps biological/scoring logic separate from I/O and shell interaction, improving reproducibility and debugging.</p>
<h2>Tests</h2>
<h3>Verification against course examples</h3>
<p>The program was verified against all four test cases in <code>project1_examples.txt</code> provided by the course:</p>
<table>
<thead>
<tr>
<th>Case</th>
<th>Sequences</th>
<th>Expected cost</th>
<th>Our cost</th>
<th>Expected count</th>
<th>Our count</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>acgtgtcaacgt vs acgtcgtagcta</td>
<td>22</td>
<td>22</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>aataat vs aagg</td>
<td>14</td>
<td>14</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>tccagaga vs tcgat</td>
<td>20</td>
<td>20</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>(long seqs, 197/196 chars)</td>
<td>325</td>
<td>325</td>
<td>288</td>
<td>288</td>
</tr>
</tbody>
</table>
<p>All cases match exactly, confirming correctness of both the cost computation and the optimal alignment counting.</p>
<p>The source snapshot contains JUnit tests covering key correctness points:</p>
<ul>
<li>
<p><code>OptimalAlignmentCounterTest</code><br />
  Validates counting behavior for both tie cases (multiple optimal alignments) and unique-optimum cases.</p>
</li>
<li>
<p><code>ScoreMatrixTest</code><br />
  Verifies matrix-file parsing and selected pairwise cost lookups.</p>
</li>
<li>
<p><code>FastaReaderTest</code><br />
  Checks FASTA parsing behavior (including lowercase and multiline sequence input).</p>
</li>
<li>
<p><code>PairwiseSmokeTest</code><br />
  Confirms the pairwise module test pipeline executes successfully in the build.</p>
</li>
<li>
<p><code>TextWrapTest</code><br />
  Verifies CLI output wrapping behavior for readable traceback output formatting.</p>
</li>
</ul>
<p>Together, these tests validate input parsing, cost lookup, DP-based outputs, and user-facing formatting.</p>
<h2>Experiments</h2>
<p>Runtime artifacts are included in:
- <code>submissions/project-1-global-linear-gap/results/timings_project1.csv</code>
- <code>submissions/project-1-global-linear-gap/results/timings_project1_plot.png</code></p>
<h3>Protocol</h3>
<ul>
<li>Warmup: 3 runs on length 500 (ignored in reported results).</li>
<li>Measured lengths: 1000, 2000, 3000, 4000, 5000.</li>
<li>Repetitions per length: 5.</li>
<li>Reported metric: median runtime (plus minimum runtime).</li>
<li>Plot uses <strong>DP cells (<code>n*m</code>)</strong> on x-axis and runtime (seconds) on y-axis.</li>
</ul>
<h3>Exact measured values (from CSV)</h3>
<table>
<thead>
<tr>
<th style="text-align: right;">length</th>
<th style="text-align: right;">cells</th>
<th style="text-align: right;">runtime_seconds_median</th>
<th style="text-align: right;">runtime_seconds_min</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: right;">1000</td>
<td style="text-align: right;">1000000</td>
<td style="text-align: right;">0.172</td>
<td style="text-align: right;">0.153</td>
</tr>
<tr>
<td style="text-align: right;">2000</td>
<td style="text-align: right;">4000000</td>
<td style="text-align: right;">0.187</td>
<td style="text-align: right;">0.182</td>
</tr>
<tr>
<td style="text-align: right;">3000</td>
<td style="text-align: right;">9000000</td>
<td style="text-align: right;">0.234</td>
<td style="text-align: right;">0.229</td>
</tr>
<tr>
<td style="text-align: right;">4000</td>
<td style="text-align: right;">16000000</td>
<td style="text-align: right;">0.308</td>
<td style="text-align: right;">0.306</td>
</tr>
<tr>
<td style="text-align: right;">5000</td>
<td style="text-align: right;">25000000</td>
<td style="text-align: right;">0.392</td>
<td style="text-align: right;">0.382</td>
</tr>
</tbody>
</table>
<h3>Interpretation</h3>
<ul>
<li>Runtime grows monotonically from 0.17s (1M cells) to 0.39s (25M cells).</li>
<li>The growth is consistent with the expected (O(nm)) time complexity: a 25x increase in cells produces roughly a 2.3x increase in runtime, which aligns with linear scaling once JVM startup overhead is accounted for.</li>
<li>The JVM startup cost (roughly 0.15s) is visible as a baseline offset; subtracting it reveals near-linear scaling with DP cell count.</li>
<li>Warmup runs and median-of-5 reporting reduce JIT and system noise.</li>
</ul>
<h2>How to run</h2>
<h3>A. One-click run (recommended for tutor)</h3>
<p>Use the folder:
<code>submissions/project-1-global-linear-gap/run/</code></p>
<ul>
<li><strong>Windows:</strong> double-click:</li>
<li><code>RUN_GLOBAL_LINEAR.bat</code></li>
<li><code>RUN_GLOBAL_COUNT.bat</code></li>
<li><strong>Mac/Linux:</strong> run:</li>
<li><code>./RUN_GLOBAL_LINEAR.sh</code></li>
<li><code>./RUN_GLOBAL_COUNT.sh</code></li>
</ul>
<p>Output files appear in:
<code>submissions/project-1-global-linear-gap/run/output/</code></p>
<h3>B. Command-line run (reproducible)</h3>
<p>From <code>submissions/project-1-global-linear-gap/</code>:</p>
<p><code>global_linear</code> with traceback and custom output:</p>
<pre><code class="language-bash">java -jar run/bioseq-cli.jar global_linear --fasta1 &lt;file&gt; --fasta2 &lt;file&gt; --matrix &lt;file&gt; --gap 5 --traceback --out &lt;file&gt;
</code></pre>
<p><code>global_count</code>:</p>
<pre><code class="language-bash">java -jar run/bioseq-cli.jar global_count --fasta1 &lt;file&gt; --fasta2 &lt;file&gt; --matrix &lt;file&gt; --gap 5 --out &lt;file&gt;
</code></pre>
<p>Example placeholders:
- <code>&lt;file&gt;</code> for FASTA inputs can be paths such as <code>run/examples/seq1.fa</code> and <code>run/examples/seq2.fa</code>
- matrix path can be <code>run/examples/dna_matrix.txt</code></p>
<h3>Build from bundled source snapshot</h3>
<p>From <code>submissions/project-1-global-linear-gap/code/</code>:</p>
<p>Windows:</p>
<pre><code class="language-bat">mvnw.cmd -q test
mvnw.cmd -q -pl cli -am package
</code></pre>
<p>Mac/Linux:</p>
<pre><code class="language-bash">./mvnw -q test
./mvnw -q -pl cli -am package
</code></pre>
<p>The runnable jar in <code>run/</code> was built from this source snapshot.</p>
<h2>Checklist for submission</h2>
<ul>
<li><code>run/</code> contains runnable scripts and <code>bioseq-cli.jar</code>.</li>
<li><code>run/output/</code> contains example output files after execution.</li>
<li><code>code/</code> contains source snapshot (<code>core</code>, <code>pairwise-alignment</code>, <code>cli</code>).</li>
<li><code>results/</code> contains <code>timings_project1.csv</code> and <code>timings_project1_plot.png</code>.</li>
<li><code>project1_eval_answers.txt</code> is filled with Q1/Q2/Q3 answers.</li>
<li><code>report.md</code> is present and ready for export to PDF if needed.</li>
</ul></body></html>